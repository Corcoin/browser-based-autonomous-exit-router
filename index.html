<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Autonomous Exit Router (Async)</title>
<style>
body { font-family: sans-serif; padding: 20px; }
#log { white-space: pre-wrap; background: #f4f4f4; padding: 10px; height: 400px; overflow-y: scroll; border: 1px solid #ccc; }
button { padding: 10px 20px; margin-bottom: 10px; }
</style>
</head>
<body>
<h1>Autonomous Exit Router (Async)</h1>
<button onclick="runTest()">Run Test</button>
<div id="log"></div>

<script>
// ---------------------------
// Hardcoded routing table JSON
// ---------------------------
const ROUTES = {
  "fast": ["youtube.com", "google.com", "facebook.com"],
  "low_latency": ["discord.com", "zoom.us"],
  "bulk": ["windowsupdate.com", "apple.com"]
};

const HOSTS = {
  "youtube.com": "142.250.190.174",
  "google.com": "142.250.190.78",
  "facebook.com": "157.240.22.35",
  "discord.com": "162.159.134.232",
  "zoom.us": "52.10.23.99",
  "windowsupdate.com": "13.107.246.44",
  "apple.com": "17.172.224.47"
};

const EXITS = {
  "fast": [
    {"ip": "142.250.190.174", "port": 443, "buffer": 65535},
    {"ip": "142.250.190.78", "port": 443, "buffer": 65535}
  ],
  "low_latency": [
    {"ip": "162.159.134.232", "port": 443, "buffer": 16384},
    {"ip": "52.10.23.99", "port": 443, "buffer": 16384}
  ],
  "bulk": [
    {"ip": "13.107.246.44", "port": 443, "buffer": 131072},
    {"ip": "17.172.224.47", "port": 443, "buffer": 131072}
  ],
  "default": [
    {"ip": "8.8.8.8", "port": 53, "buffer": 65535}
  ]
};

// ---------------------------
// Logging helper
// ---------------------------
function log(msg) {
  const el = document.getElementById("log");
  el.textContent += msg + "\n";
  el.scrollTop = el.scrollHeight;
}

// ---------------------------
// Routing logic
// ---------------------------
function classifyHost(hostname) {
  hostname = hostname.toLowerCase();
  for (const [bucket, domains] of Object.entries(ROUTES)) {
    for (const d of domains) {
      if (hostname.endsWith(d)) return bucket;
    }
  }
  return "default";
}

function selectExit(bucket) {
  const exits = EXITS[bucket] || EXITS["default"];
  if (!exits || exits.length === 0) return null;
  // Shuffle for load balancing
  return exits[Math.floor(Math.random() * exits.length)];
}

// ---------------------------
// Simulated connection (async, DNS-free)
// ---------------------------
async function connect(hostname) {
  const bucket = classifyHost(hostname);
  const exitNode = selectExit(bucket);

  if (!exitNode) {
    log(`[FAIL] No exit for ${hostname}`);
    return;
  }

  const ip = HOSTS[hostname] || exitNode.ip;
  const port = exitNode.port;

  try {
    // Use fetch as simulation; in production could use WebSockets or other protocols
    await fetch(`https://${ip}/`, {mode:"no-cors"});
    log(`[CALL] ${hostname} routed via ${ip} (${bucket})`);
    // Monetization: increment counter here
    incrementCall(hostname, ip);
  } catch (e) {
    log(`[FAIL] ${hostname} -> ${ip}: ${e}`);
    // Failover: try another exit from same bucket if available
    const exits = EXITS[bucket].filter(e => e.ip !== ip);
    if (exits.length > 0) {
      const failover = exits[Math.floor(Math.random() * exits.length)];
      log(`[RETRY] Trying failover exit ${failover.ip}`);
      try {
        await fetch(`https://${failover.ip}/`, {mode:"no-cors"});
        log(`[CALL-RETRY] ${hostname} routed via ${failover.ip} (${bucket})`);
        incrementCall(hostname, failover.ip);
      } catch (err) {
        log(`[FAIL-RETRY] ${hostname} -> ${failover.ip}: ${err}`);
      }
    }
  }
}

// ---------------------------
// Monetization / call counters
// ---------------------------
const CALL_COUNTS = {};

function incrementCall(hostname, exitIp) {
  const key = `${hostname}@${exitIp}`;
  CALL_COUNTS[key] = (CALL_COUNTS[key] || 0) + 1;
  log(`[COUNT] ${key} = ${CALL_COUNTS[key]}`);
}

// ---------------------------
// Run async test for multiple hosts
// ---------------------------
async function runTest() {
  const hosts = [
    "youtube.com", "discord.com", "windowsupdate.com", "zoom.us",
    "google.com", "apple.com", "facebook.com"
  ];
  const tasks = hosts.map(h => connect(h));
  await Promise.all(tasks); // fully concurrent
}
</script>
</body>
</html>
